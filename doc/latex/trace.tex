
\clearpage
\section{Trace Generation}

MacSim needs the trace of the running application in order to run a simulation.
The following sections explain how to generate CPU and GPU traces.

\subsection{CPU (X86) Traces}

CPU (X86) traces are generated with the aid of Pin~\cite{pin}, which
is a binary instrumentation tool.  The detail descriptions of Pin
including installation can be found in http://www.pintool.org.  After
installing Pin\footnote{Note that our CPU trace generator may not be
backward/forward compatible with the pin version. Currently, pin 41150
revision (Jun 07, 2011) must be used.}, we need to build the X86 trace
generator module (trace\_generator.so) for MacSim, which can be simply
done with the following commands.

\smallskip
\begin{lstlisting}
cd toos/x86_trace_generator
make
\end{lstlisting}
\smallskip

The above will create trace\_generator.so in the tools/x86\_trace\_generator/obj-intel64 directory.
Then, MacSim X86 traces can be simply generated by running pin along with the module in the following manner.

\smallskip
\begin{lstlisting}
pin -t trace_generator.so -- $BIN $ARGS (for single-threaded)
pin -t trace_generator.so -thread N -- $BIN $ARGS (for multi-threaded)
\end{lstlisting}
\smallskip

The following shows the example of the trace generation for /bin/ls. 
With the command of \emph{pin -t trace\_generator.so -- /bin/ls}, the binary (ls) is 
actually executed and the instructions exectued at run-time are stored into the trace file.

\smallskip
\begin{lstlisting}
pin -t trace_generator.so -- /bin/ls
-> Thread[0->0] begins.
-> Trace Generation Starts at icount 0
dump.txt_0.dump  pin.log  trace_0.raw  trace_generator.o  trace_generator.so  xed_extractor.o  xed_extractor.so
-> Trace Generation Done at icount 475195
\end{lstlisting}
\smallskip

When finishing the trace generation, the trace.txt and trace\_0.raw are created in the directory.

\subsection{GPU (PTX) Traces}

GPU (PTX) traces are generated using Ocelot~\cite{ocelot}, which is a dynamic compilation
framework for heterogenous system. 

\subsubsection{Installing Ocelot}

Ocelot can be installed either using ubuntu packages provided by the official
page or via its SVN repository. To install the latest version, check out 
source files using the following command:

\smallskip
\begin{lstlisting}
svn checkout http://gpuocelot.googlecode.com/svn/trunk/ gpuocelot
\end{lstlisting}
\smallskip

After checking out source files, you can build Ocelot and trace generator libraries using the following commands:

\smallskip
\begin{lstlisting}
cd gpuocelot/ocelot; sudo ./build.py --install
cd gpuocelot/trace-generators; libtoolize; aclocal; autoconf; automake; ./configure; 
make; sudo make install
\end{lstlisting}
\smallskip

\subsubsection{Generating Traces}

CUDA executables which are targeted to generate traces should be linked against
libocelot.so and libocelotTrace.so.

In order to generate traces, the following four environment variables need to be set.

\begin{itemize}\itemsep2pt
\item TRACE\_PATH : directory to store generated traces. If not specified, current directory is used by default.
\item TRACE\_NAME : prefix name for generated traces. If not specified, "Trace" is used by default.
\item KERNEL\_INFO\_PATH : file that contains kernel information (must be specified)
\item COMPUTE\_VERSION : compute capability (must be specified)
\end{itemize}

The following shows an example of how to set up the environment variables.

\smallskip
\begin{lstlisting}
export TRACE_PATH="/storage/traces/"     # Create a trace directory in the /storage/traces
export KERNEL_INFO_PATH="kernel_info"    # kernel_info has the kernel information
export COMPUTE_VERSION="2.0"             # Calculate occupancy based on compute capability 2.0
\end{lstlisting}
\smallskip

The kernel information file (kernel\_info) should contain the following
information: kernel name, register usage (per thread), and shared memory usage
(per thread).

\smallskip
\begin{lstlisting}
_Z9Memcpy_SWPfS_i 14 52 
\end{lstlisting}
\smallskip

Running CUDA application creates a directory with the kernel name, where traces 
are generated, and kernel\_config.txt which is a configuration used for MacSim.

\smallskip
\begin{lstlisting}
drwxr-xr-x   2 anonymous group 69632 Sep 00 22:03 _Z9Memcpy_SWPfS_i_0
-rw-r--r--   1 anonymous group    66 Sep 09 22:29 kernel_config.txt
\end{lstlisting}
\smallskip


\subsection{Trace Format}
\label{sec:traceformat}

In the generated trace, there are mainly two different types of files.
\begin{itemize}\itemsep2pt
\item Trace.txt : contains the overall information of the trace (\#thread, trace type, ...).
\item Trace\_xx.raw : contains instruction for a thread and is generated for each thread (warp in case of GPU)
\end{itemize}

First, Trace.txt contains the outline of the generated trace and the format looks as follows: 
\smallskip
\begin{lstlisting}
#Threads | Trace Type | (Optional Fields)
1st Thread ID         | Start Instruction No.
2nd Thread ID         | Start Instruction No.
...
nth Thread ID         | Start Instruction No.
\end{lstlisting}
\smallskip

\#Threads in the first line indicates the number of threads whose trace is 
generated, and the value is the same as the number of following lines. The trace
type is filled by either x86 and ptx according to the type of the trace. The following
lines indicate the thread ID and the number of instructions to skip in each thread's trace.

\begin{table*}[htb]
\begin{footnotesize}
\begin{center}
\caption{MacSim trace format.}
\label{table:trace_format}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|} 
\hline
nSR & nDR & SR\_IDs & DR\_IDs & BrType & bImm & Opcode & bStore & bFP & WF & nLD  \\ \hline \hline
InstSize & LAddr\_1 & LAddr\_2 & SAddr & PCAddr & BrAddr & MemRSize & MemWSize & RepDir & BrActT & \\ \hline
\end{tabular}
\end{center}
\end{footnotesize}
\end{table*}

For each thread ID, there exists a correspoding trace\_xx.raw file which
contains various information to execute an instruction.
Tables~\ref{table:trace_format} and ~\ref{table:trace_desc} show the trace
format for each instruction and the description of each field, respectively.

\begin{table*}[htb]
\begin{footnotesize}
\begin{center}
\caption{Descriptions of each field in the trace.}
\label{table:trace_desc}
\begin{tabular}{|l|l|l|} 
\hline
Field     & Size (Bytes)       & Description \\ \hline 
nSR       & 1                  & number of source registers \\ \hline
nDR       & 1                  & number of destiantion registers \\ \hline
SR\_IDs   & 9                  & source register IDs \\ \hline
DR\_IDs   & 6                  & destination register IDs \\ \hline
BrType    & 1                  & branch type \\ \hline
bImm      & 1                  & indicates whether this instruction has immediate field \\ \hline
Opcode    & 1                  & opcode \\ \hline
bStore    & 1                  & indicates whether this instruction has store operation \\ \hline
bFP       & 1                  & indicates whether this instruction is FP operation \\ \hline
WriteFlag & 1                  & write flag \\ \hline
nLD       & 1                  & number of load opeartions \\ \hline
InstSize  & 1                  & instruction size \\ \hline
LAddr\_1  & 4                  & load address 1 \\ \hline
LAddr\_2  & 4                  & load address 2 \\ \hline
SAddr     & 4                  & store address \\ \hline
PCAddr    & 4                  & PC address \\ \hline
BrAddr    & 4                  & branch target address \\ \hline
MemRSize  & 4                  & memory read size \\ \hline
MemWSize  & 1                  & memory write size \\ \hline
RepDir    & 1                  & repetition direction  \\ \hline
BrActT    & 1                  & indicates whether branch is actually taken \\ \hline

\end{tabular}
\end{center}
\end{footnotesize}
\end{table*}

While running a simulation, each instruction in the above \emph{raw trace} is converted 
into one or more micro-ops. MacSim stores such decoded micro-uops into a MacSim-specific
trace structure to facilitate the simulation by populating each field, which is shown 
in Table~\ref{table:trace_uops}.

\begin{table*}[htb]
\begin{footnotesize}
\begin{center}
\caption{MacSim-specific data structure for micro-ops.}
\label{table:trace_uops}
\begin{tabular}{|l|l|l|} 
\hline
Type      & Variable                 & Description \\ \hline 
uint8\_t  & m\_opcode                & opcode \\ \hline
Uop\_Type & m\_op\_type              & type of operation \\ \hline
Mem\_Type & m\_mem\_type             & type of memory instruction \\ \hline
Cf\_Type  & m\_cf\_type              & type of control flow instruction \\ \hline
Bar\_Type & m\_bar\_type             & type of barrier caused by instruction \\ \hline
uns       &   m\_num\_dest\_regs     & number of destination registers written \\ \hline
uns       &   m\_num\_src\_regs      & number of source registers read \\ \hline
uns       &   m\_mem\_size           & number of bytes read/written by a memory instruction \\ \hline
uns       &   m\_inst\_size          & instruction size \\ \hline
Addr      &   m\_addr                & pc address  \\ \hline
reg\_info\_s&   m\_srcs[MAX\_SRCS]   & source register information \\ \hline
reg\_info\_s&   m\_dests[MAX\_DESTS] & destination register information \\ \hline
Addr      &   m\_va;                 & virtual address \\ \hline
bool      &   m\_actual\_taken       & branch actually taken \\ \hline
Addr      &   m\_target              & branch target address \\ \hline
Addr      &   m\_npc                 & next pc address  \\ \hline
bool      &   m\_pin\_2nd\_mem       & has second memory operation \\ \hline
inst\_info\_s& *m\_info              & pointer to the instruction hash table  \\ \hline
int       &   m\_rep\_uop\_num       & repeated uop number \\ \hline
bool      &   m\_eom                 & end of macro \\ \hline
bool      &   m\_alu\_uop            & alu uop  \\ \hline
uint32\_t  &   m\_active\_mask       & active mask \\ \hline
uint32\_t  &   m\_taken\_mask        & branch taken mask \\ \hline
Addr      &   m\_reconverge\_addr    & address of reconvergence \\ \hline
bool      &   m\_mul\_mem\_uops      & multiple memory transactions \\ \hline

\end{tabular}
\end{center}
\end{footnotesize}
\end{table*}

\ignore{
The following shows the data structure for micro-uops. 

\smallskip
\begin{lstlisting}
  uint8_t      m_opcode;        /**< opcode */
  Uop_Type     m_op_type;       /**< type of operation */
  Mem_Type     m_mem_type;      /**< type of memory instruction */
  Cf_Type      m_cf_type;       /**< type of control flow instruction */ 
  Bar_Type     m_bar_type;      /**< type of barrier caused by instruction */
  uns          m_num_dest_regs; /**< number of destination registers written */
  uns          m_num_src_regs;  /**< number of source registers read */
  uns          m_mem_size;      /**< number of bytes read/written by a memory instruction */
  uns          m_inst_size;     /**< instruction size */
  Addr         m_addr;          /**< pc address */ 
  reg_info_s   m_srcs[MAX_SRCS]; /**< source register information */
  reg_info_s   m_dests[MAX_DESTS]; /**< destination register information */
  Addr         m_va;            /**< virtual address */
  bool         m_actual_taken;  /**< branch actually taken */
  Addr         m_target;        /**< branch target address */
  Addr         m_npc;           /**< next pc address */ 
  bool         m_pin_2nd_mem;   /**< has second memory operation */
  inst_info_s *m_info;          /**< pointer to the instruction hash table */ 
  int          m_rep_uop_num;   /**< repeated uop number */
  bool         m_eom;           /**< end of macro */
  bool         m_alu_uop;       /**< alu uop */ 
  // GPU simulation
  uint32_t     m_active_mask;   /**< active mask */
  uint32_t     m_taken_mask;    /**< branch taken mask */
  Addr         m_reconverge_addr; /**< address of reconvergence */
  bool         m_mul_mem_uops;  /**< multiple memory transactions */
\end{lstlisting}
\smallskip
}

% LocalWords:  GPU PTX gpuocelot

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ignore{
\begin{table*}[htb]
\begin{footnotesize}
\begin{center}
\caption{MacSim trace format.}
\label{table:trace_format}
\begin{tabular}{|l|l|} 
\hline
Type               & Description \\ \hline 
uint8\_t           & number of source registers \\ \hline
uint8\_t           & number of destiantion registers \\ \hline
uint8\_t[9]        & source register IDs \\ \hline
uint8\_t[6]        & destination register IDs \\ \hline
uint8\_t           & branch type \\ \hline
bool               & indicates whether this instruction has immediate field \\ \hline
uint8\_t           & opcode \\ \hline
bool               & indicates whether this instruction has store operation \\ \hline
bool               & indicates whether this instruction is FP operation \\ \hline
bool               & write flag \\ \hline
uint8\_t           & number of load opeartions \\ \hline
uint8\_t           & instruction size \\ \hline
uint32\_t          & load address 1 \\ \hline
uint32\_t          & load address 2 \\ \hline
uint32\_t          & store address \\ \hline
uint32\_t          & PC address \\ \hline
uint32\_t          & branch target address \\ \hline
uint32\_t          & memory read size \\ \hline
uint8\_t           & memory write size \\ \hline
uint8\_t           & repetition direction  \\ \hline
uint8\_t           & indicates whether branch is actually taken \\ \hline

\end{tabular}
\end{center}
\end{footnotesize}
\end{table*}
}

